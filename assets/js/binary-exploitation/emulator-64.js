const keystone = new ks.Keystone(ks.ARCH_X86, ks.MODE_64);
keystone.option(ks.OPT_SYNTAX, ks.OPT_SYNTAX_INTEL);
const capstone = new cs.Capstone(cs.ARCH_X86, cs.MODE_64);
capstone.option(cs.OPT_SYNTAX, cs.OPT_SYNTAX_INTEL);
const unicorn = new uc.Unicorn(uc.ARCH_X86, uc.MODE_64);
unicorn.set_integer_type(ELF_INT_OBJECT);


class Code{
    constructor(code_start, name){
        this._arr = [];
        this.code_start = code_start;
        this.mapped = false;
        this.name = name;
    }
    get length(){return this.arr.length;}
    get start(){return this.code_start;}
    get end(){return this.code_start + this.length;}
    set code(code){ this.arr = Array.from(keystone.asm(code));}

    allocate(){
        // current hard code the code size to be 4KB
        if(this.mapped) unicorn.mem_unmap(this.start, 4*1024);
        unicorn.mem_map(this.start, 4*1024, uc.PROT_ALL);
        this.mapped = true;
    }
    get arr(){return this._arr;}
    set arr(array){
        this._arr = array;
        unicorn.mem_write(this.start, this._arr);
    }

    run(){
        unicorn.emu_start(this.start, this.end, 0, 0);
    }

    render(){
        const result = capstone.disasm(this.arr, this.start);
        const div = document.createElement("div");
        div.classList.add("code-block")
        div.innerHTML = "<h3>" + this.name + "</h3>";
        const table = document.createElement("table");
        table.className = "table table-sm table-striped table-bordered border-black"
        table.innerHTML = "<thead><tr><th>Address</th><th>Instruction</th></tr><thead>";
        const table_body = document.createElement('tbody');
        table_body.className = "code-font";
        table.appendChild(table_body);
        for(let i = 0; i < result.length; i++){
            const tr = document.createElement("tr");
            tr.setAttribute("addr", result[i].address.toString(16));
            const address_td = document.createElement("td");
            const instruction_td = document.createElement("td");
            address_td.classList.add("table-name");
            address_td.classList.add("table-value");
            address_td.id = result[i].address.toString(16) + "-address";
            instruction_td.classList.add("table-name");
            instruction_td.classList.add("table-value");
            instruction_td.id = result[i].address.toString(16) + "-value";
            address_td.innerHTML = result[i].address.toString(16);
            instruction_td.innerHTML = result[i].mnemonic + ' ' + result[i].op_str;
            instruction_td.setAttribute('data-tooltip', result[i].bytes.map((byte)=>{return byte.toString(16).padStart(2, "0")}).join(" "));
            tr.appendChild(address_td);
            tr.appendChild(instruction_td);
            table_body.appendChild(tr);
        }
        div.appendChild(table);
        instructions.appendChild(div);
    }
}

class Function extends Code{
    constructor(code_start, name, code, allocate=true){
        super(code_start, name);
        if(allocate) this.allocate();
        if(code !== undefined){
            this.code = code;
        }
    }
}


class Stack{
    constructor(stack_top, size){
        this.stack_top = stack_top;
        this.size = size;

    }
    allocate(){
        unicorn.mem_map(this.stack_top - this.size, this.size, uc.PROT_READ | uc.PROT_WRITE);
        unicorn.reg_write_i64(uc.X86_REG_RSP, this.stack_top);
        unicorn.reg_write_i64(uc.X86_REG_RBP, this.stack_top);
    }
}

class Register{
    constructor(name, id){
        this.name = name;
        this.id = id;
    }
}

class RegisterTable{
    constructor(){
        this.registers = [new Register("RAX", uc.X86_REG_RAX), new Register("RBX", uc.X86_REG_RBX), new Register("RCX", uc.X86_REG_RCX), new Register("RDX", uc.X86_REG_RDX), new Register("RSI", uc.X86_REG_RSI), new Register("RDI", uc.X86_REG_RDI), new Register("RBP", uc.X86_REG_RBP), new Register("RSP", uc.X86_REG_RSP), new Register("RIP", uc.X86_REG_RIP), new Register("R8", uc.X86_REG_R8), new Register("R9", uc.X86_REG_R9), new Register("R10", uc.X86_REG_R10), new Register("R11", uc.X86_REG_R11), new Register("R12", uc.X86_REG_R12), new Register("R13", uc.X86_REG_R13), new Register("R14", uc.X86_REG_R14), new Register("R15", uc.X86_REG_R15)];
        this.registers_table = document.getElementById("registers");
    }

    populate(){
        this.registers_table.innerHTML = "";
        const header_thead = document.createElement("thead");
        const header_tr = document.createElement("tr");
        const name_th = document.createElement("th");
        const value_th = document.createElement("th");
        name_th.innerHTML = "Name";
        value_th.innerHTML = "Value";
        header_tr.appendChild(name_th);
        header_tr.appendChild(value_th);
        header_thead.appendChild(header_tr);
        this.registers_table.appendChild(header_thead);

        const table_body = document.createElement("tbody");
        table_body.className = "code-font";
        this.registers_table.appendChild(table_body);
        for(let register of this.registers){
            const tr = document.createElement("tr");
            const name_td = document.createElement("td");
            const value_td = document.createElement("td");
            name_td.classList.add("table-name");
            name_td.id = register.name + "-name";
            value_td.classList.add("table-name");
            value_td.classList.add("table-value");
            value_td.id = register.name + "-value";
            name_td.innerHTML = register.name;
            let value = unicorn.reg_read_i64(register.id).hex().slice(2);
            const canonical_value = value === "0000000000000000" ? "0" : value.replace(/^0+/, "");
            value_td.innerHTML = canonical_value;
            value_td.setAttribute("canonical-value", canonical_value);
            tr.appendChild(name_td);
            tr.appendChild(value_td);
            table_body.appendChild(tr);
        }
    }
}

class StackTable{
    constructor(stack_top, render_size){
        this.stack_table = document.getElementById("stack");
        this.render_size = render_size;
        this.stack_top = stack_top;
    }
    populate(){
        this.stack_table.innerHTML = "";
        const header_thead = document.createElement("thead");
        const header_tr = document.createElement("tr");
        const address_th = document.createElement("th");
        const value_th = document.createElement("th");
        value_th.id = "stack-top";
        address_th.innerHTML = "Address";
        value_th.innerHTML = "Value";
        header_tr.appendChild(address_th);
        header_tr.appendChild(value_th);
        header_thead.appendChild(header_tr);
        this.stack_table.appendChild(header_thead);

        const table_body = document.createElement("tbody");
        table_body.className = "code-font";
        this.stack_table.appendChild(table_body);
        for(let i = 1; i <= this.render_size; i++){
            const current_addr = this.stack_top - i*8;
            const tr = document.createElement("tr");
            tr.setAttribute("addr", current_addr.toString(16));
            const address_td = document.createElement("td");
            const value_td = document.createElement("td");
            address_td.classList.add("table-name");
            address_td.classList.add("table-value");
            address_td.id = current_addr.toString(16) + "-address";
            value_td.classList.add("table-name");
            value_td.classList.add("table-value");
            value_td.id = current_addr.toString(16) + "-value";
            address_td.innerHTML = current_addr.toString(16);
            const mem = unicorn.mem_read(current_addr, 8);
            const view = new DataView(mem.buffer, 0);
            const canonical_value = view.getBigUint64(0, true).toString(16)
            value_td.innerHTML = '0x' + canonical_value;
            value_td.setAttribute("canonical-value", canonical_value);
            tr.appendChild(address_td);
            tr.appendChild(value_td);
            table_body.appendChild(tr);
        }
    }
}

let program_started = false;
/*
let current_highlight = null;
function clear_highlight_rip(){
    if(current_highlight != null){
        current_highlight.style.backgroundColor = "";
    }
}
function clear_and_highlight_rip(rip){
    clear_highlight_rip();
    const current_instruction = document.querySelector(`[addr="${rip.toString(16)}"]`);
    if(current_instruction !== null){
        current_instruction.style.backgroundColor = "gray";
        current_highlight = current_instruction;
    }
}
let current_rsp = null;
function clear_highlight_rsp(){
    if(current_rsp != null){
        current_rsp.style.backgroundColor = "";
    }
}
function clear_and_highlight_rsp(){
    clear_highlight_rsp();
    const current_rsp_addr = unicorn.reg_read_i64(uc.X86_REG_RSP);
    const current_rsp_tr = document.querySelector(`[addr="${current_rsp_addr.toString(16)}"]`);
    if(current_rsp_tr !== null){
        current_rsp_tr.style.backgroundColor = "gray";
        current_rsp = current_rsp_tr;
    }
}

let arrows_list = [];
function reset_arrows(){
    arrows_list.forEach((elem)=>{elem.containerDiv.remove()})
    arrows_list = [];
}
*/

// based on https://stackoverflow.com/questions/123999/how-can-i-tell-if-a-dom-element-is-visible-in-the-current-viewport

function isElementInEnclosingElement (el, enclosingEl) {
    // Special bonus for those using jQuery
    if (typeof jQuery === "function" && el instanceof jQuery) {
        el = el[0];
    }
    const rect = el.getBoundingClientRect();
    const enclosingRect = enclosingEl.getBoundingClientRect();
    return (
        rect.top >= enclosingRect.top &&
        rect.left >= enclosingRect.left &&
        rect.bottom <= enclosingRect.bottom &&
        rect.right <= enclosingRect.right
    )
    // return (
    //     rect.top >= 0 &&
    //     rect.left >= 0 &&
    //     rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && /* or $(window).height() */
    //     rect.right <= (window.innerWidth || document.documentElement.clientWidth) /* or $(window).width() */
    // );
} 

/**
 * This function just returns an `SVGMarkerElement` that's already pre-styled and so on
 */
/*
const createMarker = (name, color)=> {
    const arrow = document.createElementNS(SvgDomArrows.SVGNS, 'path');
    const marker = document.createElementNS(SvgDomArrows.SVGNS, 'marker');
  
    arrow.setAttribute('d', 'M 0 0 L 10 5 L 0 10 z');
    arrow.setAttribute('style', `fill:${color};stroke-width:0.801524;stroke-miterlimit:4;stroke-dasharray:none`);
  
    marker.setAttribute('id', `marker${name}`); // <== Make sure to set an id attribute
    */
    /**
     * The below attributes and values are specific to this marker, you'll have to know how markers work
     * to really do something fun. For now you'll have to deal with it manually but I might work on an SVG
     * marker utility.
     */
    /*
    marker.setAttribute('refX', '5');
    marker.setAttribute('refY', '5');
    marker.setAttribute('viewBox', '0 0 10 10');
    marker.setAttribute('orient', 'auto-start-reverse'); // <== There is a trick here, be sure to read after the code snippet
    marker.setAttribute('markerWidth', '6');
    marker.setAttribute('markerHeight', '6');
    marker.appendChild(arrow);
    return marker;
  };
  */

function render_stack_pointer_arrow(register){
    // register: string: rbp or rsp
    const src = document.getElementById(register + "-name");
    const register_value_elem = document.getElementById(register + "-value");
    const register_value = register_value_elem.getAttribute("canonical-value");
    let points_to = document.getElementById(register_value + "-value");
    let points_to_position = {top: .5, left: 1};
    if(register_value === stack.stack_top.toString(16)){
        points_to = document.getElementById("stack-top");
        points_to_position = {top: 1, left: 1};
    }
    if((points_to === null) || !isElementInEnclosingElement(points_to, stack_table.stack_table)) return;
    // let Obj = register === "RSP" ? SvgDomArrows.SquarePath: SvgDomArrows.LinePath;
    let color = register === "RSP" ? "red" : "blue";
    let arrow = new SvgDomArrows.LinePath({
        start: {
            element: src,
            position: {top: .5, left: 0}
        }, end: {
            element: points_to,
            position: points_to_position,
            markerId: `#marker${register}`
        }, style: `stroke:${color};stroke-width:2;fill:transparent;pointer-events:none`,
        appendTo: document.body,
        markers: [createMarker(register, color)]
    })
    arrow.containerDiv.style.pointerEvents = "none";
    arrows_list.push(arrow);
}

//New render for stack pointer
function render_stack_pointer_position(register){
    // register: string: rbp or rsp
    const src = document.getElementById(register + "-name");
    const register_value_elem = document.getElementById(register + "-value");
    const register_value = register_value_elem.getAttribute("canonical-value");
    let points_to = document.getElementById(register_value + "-value");

    let color = register === "RSP" ? "bg-danger-subtle" : "bg-primary-subtle";
    register_value_elem.className = color;

    if((points_to === null)) return;
    points_to.className = color;
}


function render_rip_arrow(){
    const register_value_elem = document.getElementById("RIP-value");
    const register_value = register_value_elem.getAttribute("canonical-value");
    let points_to = document.getElementById(register_value + "-address");
    let points_to_position = {top: .5, left: 0};
    if((points_to === null) || !isElementInEnclosingElement(points_to, document.getElementById("instructions"))) return;
    let arrow = new SvgDomArrows.SquarePath({
        start: {
            element: register_value_elem,
            position: {top: .5, left: 1}
        }, end: {
            element: points_to,
            position: points_to_position,
            markerId: `#markerRIP`
        }, style: `stroke:#F5F5DC;stroke-width:2;fill:transparent;pointer-events:none`,
        appendTo: document.body,
        markers: [createMarker('RIP', '#F5F5DC')]
    })
    arrow.containerDiv.style.pointerEvents = "none";
    arrows_list.push(arrow);
}

//New render for rip
const position_array = [];
function render_rip_position(){
    const register_value_elem = document.getElementById("RIP-value");
    const register_value = register_value_elem.getAttribute("canonical-value");
    let points_to = document.getElementById(register_value + "-address");
    if((points_to === null)) return;

    register_value_elem.className = "bg-success-subtle";
    points_to.className = "bg-success-subtle";
    position_array.push(points_to);
    //console.log(register_value_elem);
    //console.log(points_to)
    //console.log(position_array)
    if(position_array.length > 1 && position_array[0] !== position_array [[1]]){
        position_array[position_array.length - 2].classList.remove("bg-success-subtle");
        position_array.shift();
    }
}

//For dynamic display of the button
function step_mode(){
    if(document.getElementById("step-mode").checked ){
        document.getElementById("step-mode-checked").classList.remove("d-none");
        document.getElementById("step-mode-checked").className = "d-block";

        document.getElementById("input-mode").classList.remove("d-block");
        document.getElementById("input-mode").className = "d-none";
    }
    if(!document.getElementById("step-mode").checked ){
        document.getElementById("step-mode-checked").classList.remove("d-block");
        document.getElementById("step-mode-checked").className = "d-none";

        document.getElementById("input-mode").classList.remove("d-none");
        document.getElementById("input-mode").className = "d-block";
    }
}

function runCode(){
    const rip = program_started ? unicorn.reg_read_i64(uc.X86_REG_RIP) : main_function.start;
    try{
        if(!is_step_mode()){
            unicorn.emu_start(rip, main_function.end, 0, 0);
        }else{
            unicorn.emu_start(rip, main_function.end, 0, 1);
        }
    }catch(e){
        throw e;
    }finally{
        program_started = true;
        render();
    }
}

function render(){
    // const rip = program_started ? unicorn.reg_read_i64(uc.X86_REG_RIP) : main_function.start;
    registers_table.populate();
    stack_table.populate();
    render_arrows();
}
function render_arrows(){
    //reset_arrows();
    //render_stack_pointer_arrow("RSP");
    //render_stack_pointer_arrow("RBP");

    render_stack_pointer_position("RSP");
    render_stack_pointer_position("RBP");
    render_rip_position();
}

function is_step_mode(){
    return document.getElementById("step-mode").checked;
}

